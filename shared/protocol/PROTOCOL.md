# Протокол передачи TCP данных через файлы

Простой протокол для передачи TCP данных между CALLER и LISTENER через облачное хранилище.

## Общая схема

```
CALLER создает запрос → LISTENER обрабатывает → LISTENER создает ответ → CALLER читает ответ
```

## Структура файлов

Все файлы хранятся в облачном хранилище в следующих папках:
- `requests/` - папка для запросов от CALLER
- `responses/` - папка для ответов от LISTENER

### Формат запроса

CALLER создает два файла для каждого запроса:

1. **`requests/{requestId}.req`** - JSON файл с метаданными запроса
2. **`requests/{requestId}.data`** - бинарный файл с данными для отправки на GOAL

#### Формат `{requestId}.req` (JSON):

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "targetAddress": "example.com",
  "targetPort": 443,
  "timestamp": 1234567890
}
```

Поля:
- `requestId` (string) - уникальный идентификатор запроса (UUID v4)
- `targetAddress` (string) - адрес целевого сервера (GOAL)
- `targetPort` (number) - порт целевого сервера (1-65535)
- `timestamp` (number) - Unix timestamp создания запроса (опционально, для отладки)

#### Формат `{requestId}.data` (binary):

Бинарный файл содержит данные для отправки на целевой сервер (GOAL). Это могут быть любые TCP данные (HTTP запросы, TLS handshake и т.д.).

### Формат ответа

LISTENER создает один файл для ответа:

1. **`responses/{requestId}.resp`** - бинарный файл с данными ответа от GOAL

#### Формат `{requestId}.resp` (binary):

Бинарный файл содержит данные, полученные от целевого сервера (GOAL).

## Поток работы

### 1. CALLER создает запрос

1. Генерирует уникальный `requestId` (UUID v4)
2. Создает файл `requests/{requestId}.req` с метаданными (JSON)
3. Создает файл `requests/{requestId}.data` с данными для отправки (binary)
4. Начинает polling для проверки наличия ответа `responses/{requestId}.resp`

**Важно**: Сначала создается `.req` файл, затем `.data` файл. LISTENER обрабатывает запрос только когда оба файла присутствуют.

### 2. LISTENER обрабатывает запрос

1. Обнаруживает новый файл `requests/{requestId}.req` (через polling)
2. Проверяет наличие соответствующего файла `requests/{requestId}.data`
3. Читает метаданные из `.req` файла
4. Читает данные из `.data` файла
5. Подключается к целевому серверу `targetAddress:targetPort`
6. Отправляет данные на целевой сервер
7. Читает ответ от целевого сервера
8. Записывает ответ в файл `responses/{requestId}.resp`
9. Удаляет файлы запроса (`{requestId}.req` и `{requestId}.data`) для очистки

### 3. CALLER получает ответ

1. Обнаруживает файл `responses/{requestId}.resp` (через polling)
2. Читает данные из файла
3. Передает данные приложению через SOCKS5
4. Удаляет файл ответа `{requestId}.resp` для очистки

## Обработка ошибок

### Ошибка подключения к GOAL

Если LISTENER не может подключиться к целевому серверу, создается файл `responses/{requestId}.error` с JSON описанием ошибки:

```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "error": "Connection refused",
  "code": "CONNECTION_ERROR",
  "timestamp": 1234567890
}
```

CALLER должен проверять наличие как `.resp`, так и `.error` файлов.

### Таймаут

Если ответ не получен в течение определенного времени (например, 60 секунд), CALLER может:
- Повторить запрос с новым `requestId`
- Удалить старые файлы запроса

## Примеры

### Пример запроса

**`requests/550e8400-e29b-41d4-a716-446655440000.req`**:
```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "targetAddress": "www.google.com",
  "targetPort": 443,
  "timestamp": 1704067200
}
```

**`requests/550e8400-e29b-41d4-a716-446655440000.data`**:
```
[бинарные данные HTTP запроса или TLS handshake]
```

### Пример ответа

**`responses/550e8400-e29b-41d4-a716-446655440000.resp`**:
```
[бинарные данные ответа от GOAL]
```

### Пример ошибки

**`responses/550e8400-e29b-41d4-a716-446655440000.error`**:
```json
{
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "error": "Connection timeout",
  "code": "TIMEOUT",
  "timestamp": 1704067260
}
```

## Особенности реализации

### Генерация requestId

Используйте UUID v4 для генерации уникальных идентификаторов:
- TypeScript/Deno: `crypto.randomUUID()`
- Kotlin: `UUID.randomUUID().toString()`

### Порядок операций

1. CALLER создает `.req`, затем `.data` (атомарность не гарантируется, но порядок важен)
2. LISTENER обрабатывает только когда оба файла присутствуют
3. LISTENER удаляет файлы запроса после обработки
4. CALLER удаляет файл ответа после чтения

### Polling интервалы

- LISTENER: проверка новых запросов каждые 1-5 секунд
- CALLER: проверка ответов каждые 1-3 секунды (можно чаще, так как ответы ожидаются)

### Очистка старых файлов

Рекомендуется периодически удалять старые файлы:
- Запросы старше 1 часа без ответа
- Ответы старше 1 часа без чтения

## Безопасность

- Все данные передаются в открытом виде в облачном хранилище
- Для защиты данных рекомендуется использовать TLS на уровне приложения (например, TLS поверх TCP)
- OAuth токены должны храниться безопасно и не попадать в файлы запросов

